// TRICORE-tasking.ldscript
//
// Minimal TC233 CPU description for Tasking linker.
//
// This file contains a stripped-down CPU description for the Tasking
// linker. It was created using a trial-and-error
// method, starting with an empty file and adding the only the portions
// that the linker complained about.
//
// (c) Elektrobit Automotive GmbH
//
// $Id$

architecture TC
{
	endianness
	{
		little;
	}

	space linear
	{
		id = 1;
		mau = 8;

		map (src_offset=0x00000000, dest_offset=0x00000000, size=4G, dest=bus:fpi_bus);

		copytable (align = 1 << 2, copy_unit = 1, dest = linear);
	}

	bus fpi_bus
	{
		mau = 8;
		width = 32;
	}
}

architecture TC1V1.6.X extends TC
{
}

processor spe
{
	derivative = tc233;
}

derivative tc233
{
	core tc
	{
		architecture = TC1V1.6.X;
	}

	bus fpi_bus
	{
		mau = 8;
		width = 32;
		map (dest=bus:tc:fpi_bus, dest_offset=0, size=4G);
	}
}

// ----------------------------
// Memory layout 
// ----------------------------
//
// The internal RAM (184 KB DSPR; it's a TC1.6E core) is divided between
// Code, data & CSAs Default allocation:
//   152KB (0xd0000000 - 0xd0025FFF) --> data
//   32KB (0xd0026000 - 0xd002DFFF) --> CSA
// To change this allocation, simply edit the 'int_ram' mapping and the
// CSA begin and end markers in this file.

// Flash ROM at 0x80000000 (2MB), PMU0, cached
memory int_rom_0
{
	mau = 8;
	size = 524288;
	type = rom;
	map (dest=bus:spe:fpi_bus, dest_offset=0x80000000, size=524288);
}

memory int_rom_1
{
	mau = 8;
	size = 1572864;
	type = rom;
	map (dest=bus:spe:fpi_bus, dest_offset=0x80080000, size=1572864);
}

// The size of the internal RAM segment is set to 152k here. The remaining
// 32k is reserved for CSAs. If you need more data memory or more CSAs, you
// can increase one at the expense of the other by changing the size of the
// int_ram region and the BEGIN address of the CSA region (below)
memory int_ram
{
	mau = 8;
	size = 152k;
	type = ram;
	map (dest=bus:spe:fpi_bus, dest_offset=0x70000000, size=152k);
}

// reserved sections
section_setup spe:tc:linear
{
    // According to Tasking compiler user guide the reserved keyword is used, like
    // reserved start_address .. end_address;
    // For compiler v4.x we had to add +1 to end_address cause the linker tries
    // to link to adress 0x8001bfff.

	reserved 0x80014000 .. 0x80018000;  // S5 Tuning Protection
	reserved 0x80018000 .. 0x8001c000;  // S6 HSM
	reserved 0x80060000 .. 0x80070000;  // S16 HSM
	reserved 0x80070000 .. 0x80080000;  // S17 HSM
}

// Where the CSA memory is located:
// OS_CSAMEMORY_BEGIN is the base of the CSA block
// OS_CSAMEMORY_END is the limit - i.e. the first address that won't be
// used as a CSA
//
// These must be aligned on 64-byte boundaries (lower 6 bits all zero),
// otherwise the initialisation function will round them and you might end
// up with fewer CSAs than you expect.
section_layout spe:tc:linear
{
  "MK_RSA_MK_Csa"  := 0xd0026000;
  "MK_RLA_MK_Csa"  := 0xd002E000;
}

// Sections necessary for the Infineon Fls module
// See chapter 2.1.3 in Fls User Manual PDF file.
section_layout spe:tc:linear
{
    group FLS_AC_ERASE_SOURCE (ordered,contiguous,run_addr = mem:int_rom_1, align=8)
    {
        select ".text.FLS_AC_ERASE_SOURCE";
    }
}

section_layout spe:tc:linear
{
    group FLS_AC_WRITE_SOURCE (ordered,contiguous,run_addr = mem:int_rom_1, align=8)
    {
        select ".text.FLS_AC_WRITE_SOURCE";
    }
}

section_layout spe:tc:linear
{
    group FLS_AC_WRITE (ordered, run_addr = mem:int_rom_1, align=8)
    {
        reserved "FLS_AC_WRITE" (alloc_allowed = absolute, size = 200);
    }
}

section_layout spe:tc:linear
{
    group FLS_AC_ERASE (ordered, run_addr = mem:int_rom_1, align=8)
    {
        reserved "FLS_AC_ERASE" (alloc_allowed = absolute, size = 200);
    }
}

// Linker script for the TRICORE system.
//
// GENERATED FILE: DO NOT EDIT
// Generated by genld-TRICORE-tasking-Mk.pl on 2016-12-02 15:23
//

section_layout spe:tc:linear
{
  group __AREA_text_MK (contiguous, ordered, run_addr = mem:int_rom_0[0])
  {
    // Vector tables at start of ROM
    group text.vectors (contiguous, ordered)
    {
      select "MK_bootword";
      select "MK_inttable";
      select "MK_reset";
    }
  }
  
  group __AREA_text (contiguous, ordered, run_addr = mem:int_rom_1[0])
  {
    group text.TRICORE (contiguous, ordered, align=8)
    {
      section "text.TRICORE" (blocksize=8, attributes=rx, fill=0)
      {
        select ".text*";
        select ".mk_text.*";
        select ".os_text.*";
        select ".rdata.*";
      }
    }
  }

  group __AREA_rodata (contiguous, ordered, run_addr = mem:int_rom_1, align=8)
  {
    section "__AREA_rodata" (blocksize=8, attributes=r, fill=0)
    {
      select ".rodata*";
    }
  }

  group __AREA_mk_stack (contiguous, ordered, run_addr = mem:int_ram)
  {
    group mk_stack_MK_kernStack (contiguous, ordered, align=64)
    {
      section "mk_stack_MK_kernStack" (blocksize=8, attributes=rw)
      {
        select ".bss.mk_stack_MK_kernStack";
      }
    }
    "MK_RSA_MK_kernStack" := "_lc_gb_mk_stack_MK_kernStack";
    "MK_RLA_MK_kernStack" := "_lc_ge_mk_stack_MK_kernStack";
    group (align=8) { reserved "rsrvd.mk_stack_MK_kernStack" (size=8); }

    group mk_stack_MK_idleStack (contiguous, ordered, align=64)
    {
      section "mk_stack_MK_idleStack" (blocksize=8, attributes=rw)
      {
        select ".bss.mk_stack_MK_idleStack";
      }
    }
    "MK_RSA_MK_idleStack" := "_lc_gb_mk_stack_MK_idleStack";
    "MK_RLA_MK_idleStack" := "_lc_ge_mk_stack_MK_idleStack";
    group (align=8) { reserved "rsrvd.mk_stack_MK_idleStack" (size=8); }

    group mk_stack_MK_osThreadLowStack (contiguous, ordered, align=64)
    {
      section "mk_stack_MK_osThreadLowStack" (blocksize=8, attributes=rw)
      {
        select ".bss.mk_stack_MK_osThreadLowStack";
      }
    }
    "MK_RSA_MK_osThreadLowStack" := "_lc_gb_mk_stack_MK_osThreadLowStack";
    "MK_RLA_MK_osThreadLowStack" := "_lc_ge_mk_stack_MK_osThreadLowStack";
    group (align=8) { reserved "rsrvd.mk_stack_MK_osThreadLowStack" (size=8); }

    group mk_stack_MK_initThreadStack (contiguous, ordered, align=64)
    {
      section "mk_stack_MK_initThreadStack" (blocksize=8, attributes=rw)
      {
        select ".bss.mk_stack_MK_initThreadStack";
      }
    }
    "MK_RSA_MK_initThreadStack" := "_lc_gb_mk_stack_MK_initThreadStack";
    "MK_RLA_MK_initThreadStack" := "_lc_ge_mk_stack_MK_initThreadStack";
    group (align=8) { reserved "rsrvd.mk_stack_MK_initThreadStack" (size=8); }

    group mk_stack_MK_osThreadHighStack (contiguous, ordered, align=64)
    {
      section "mk_stack_MK_osThreadHighStack" (blocksize=8, attributes=rw)
      {
        select ".bss.mk_stack_MK_osThreadHighStack";
      }
    }
    "MK_RSA_MK_osThreadHighStack" := "_lc_gb_mk_stack_MK_osThreadHighStack";
    "MK_RLA_MK_osThreadHighStack" := "_lc_ge_mk_stack_MK_osThreadHighStack";
    group (align=8) { reserved "rsrvd.mk_stack_MK_osThreadHighStack" (size=8); }

    group mk_stack_MK_protectionHookStack (contiguous, ordered, align=64)
    {
      section "mk_stack_MK_protectionHookStack" (blocksize=8, attributes=rw)
      {
        select ".bss.mk_stack_MK_protectionHookStack";
      }
    }
    "MK_RSA_MK_protectionHookStack" := "_lc_gb_mk_stack_MK_protectionHookStack";
    "MK_RLA_MK_protectionHookStack" := "_lc_ge_mk_stack_MK_protectionHookStack";
    group (align=8) { reserved "rsrvd.mk_stack_MK_protectionHookStack" (size=8); }

    group mk_stack_MK_errorHookStack (contiguous, ordered, align=64)
    {
      section "mk_stack_MK_errorHookStack" (blocksize=8, attributes=rw)
      {
        select ".bss.mk_stack_MK_errorHookStack";
      }
    }
    "MK_RSA_MK_errorHookStack" := "_lc_gb_mk_stack_MK_errorHookStack";
    "MK_RLA_MK_errorHookStack" := "_lc_ge_mk_stack_MK_errorHookStack";
    group (align=8) { reserved "rsrvd.mk_stack_MK_errorHookStack" (size=8); }

    group mk_stack_MK_tfThreadLowStack (contiguous, ordered, align=64)
    {
      section "mk_stack_MK_tfThreadLowStack" (blocksize=8, attributes=rw)
      {
        select ".bss.mk_stack_MK_tfThreadLowStack";
      }
    }
    "MK_RSA_MK_tfThreadLowStack" := "_lc_gb_mk_stack_MK_tfThreadLowStack";
    "MK_RLA_MK_tfThreadLowStack" := "_lc_ge_mk_stack_MK_tfThreadLowStack";
    group (align=8) { reserved "rsrvd.mk_stack_MK_tfThreadLowStack" (size=8); }

    group mk_stack_MK_tfThreadHighStack (contiguous, ordered, align=64)
    {
      section "mk_stack_MK_tfThreadHighStack" (blocksize=8, attributes=rw)
      {
        select ".bss.mk_stack_MK_tfThreadHighStack";
      }
    }
    "MK_RSA_MK_tfThreadHighStack" := "_lc_gb_mk_stack_MK_tfThreadHighStack";
    "MK_RLA_MK_tfThreadHighStack" := "_lc_ge_mk_stack_MK_tfThreadHighStack";
    group (align=8) { reserved "rsrvd.mk_stack_MK_tfThreadHighStack" (size=8); }

    group mk_stack_MK_selftestStack (contiguous, ordered, align=64)
    {
      section "mk_stack_MK_selftestStack" (blocksize=8, attributes=rw)
      {
        select ".bss.mk_stack_MK_selftestStack";
      }
    }
    "MK_RSA_MK_selftestStack" := "_lc_gb_mk_stack_MK_selftestStack";
    "MK_RLA_MK_selftestStack" := "_lc_ge_mk_stack_MK_selftestStack";
    group (align=8) { reserved "rsrvd.mk_stack_MK_selftestStack" (size=8); }

    group mk_stack_MK_threadStack_slot0 (contiguous, ordered, align=64)
    {
      section "mk_stack_MK_threadStack_slot0" (blocksize=8, attributes=rw)
      {
        select ".bss.mk_stack_MK_threadStack_slot0";
      }
    }
    "MK_RSA_MK_threadStack_slot0" := "_lc_gb_mk_stack_MK_threadStack_slot0";
    "MK_RLA_MK_threadStack_slot0" := "_lc_ge_mk_stack_MK_threadStack_slot0";
    group (align=8) { reserved "rsrvd.mk_stack_MK_threadStack_slot0" (size=8); }

    group mk_stack_MK_threadStack_slot1 (contiguous, ordered, align=64)
    {
      section "mk_stack_MK_threadStack_slot1" (blocksize=8, attributes=rw)
      {
        select ".bss.mk_stack_MK_threadStack_slot1";
      }
    }
    "MK_RSA_MK_threadStack_slot1" := "_lc_gb_mk_stack_MK_threadStack_slot1";
    "MK_RLA_MK_threadStack_slot1" := "_lc_ge_mk_stack_MK_threadStack_slot1";
    group (align=8) { reserved "rsrvd.mk_stack_MK_threadStack_slot1" (size=8); }

    group mk_stack_MK_threadStack_slot2 (contiguous, ordered, align=64)
    {
      section "mk_stack_MK_threadStack_slot2" (blocksize=8, attributes=rw)
      {
        select ".bss.mk_stack_MK_threadStack_slot2";
      }
    }
    "MK_RSA_MK_threadStack_slot2" := "_lc_gb_mk_stack_MK_threadStack_slot2";
    "MK_RLA_MK_threadStack_slot2" := "_lc_ge_mk_stack_MK_threadStack_slot2";
    group (align=8) { reserved "rsrvd.mk_stack_MK_threadStack_slot2" (size=8); }

    group mk_stack_MK_threadStack_slot3 (contiguous, ordered, align=64)
    {
      section "mk_stack_MK_threadStack_slot3" (blocksize=8, attributes=rw)
      {
        select ".bss.mk_stack_MK_threadStack_slot3";
      }
    }
    "MK_RSA_MK_threadStack_slot3" := "_lc_gb_mk_stack_MK_threadStack_slot3";
    "MK_RLA_MK_threadStack_slot3" := "_lc_ge_mk_stack_MK_threadStack_slot3";
    group (align=8) { reserved "rsrvd.mk_stack_MK_threadStack_slot3" (size=8); }

    group mk_stack_MK_threadStack_slot4 (contiguous, ordered, align=64)
    {
      section "mk_stack_MK_threadStack_slot4" (blocksize=8, attributes=rw)
      {
        select ".bss.mk_stack_MK_threadStack_slot4";
      }
    }
    "MK_RSA_MK_threadStack_slot4" := "_lc_gb_mk_stack_MK_threadStack_slot4";
    "MK_RLA_MK_threadStack_slot4" := "_lc_ge_mk_stack_MK_threadStack_slot4";
    group (align=8) { reserved "rsrvd.mk_stack_MK_threadStack_slot4" (size=8); }

    group mk_stack_MK_threadStack_slot5 (contiguous, ordered, align=64)
    {
      section "mk_stack_MK_threadStack_slot5" (blocksize=8, attributes=rw)
      {
        select ".bss.mk_stack_MK_threadStack_slot5";
      }
    }
    "MK_RSA_MK_threadStack_slot5" := "_lc_gb_mk_stack_MK_threadStack_slot5";
    "MK_RLA_MK_threadStack_slot5" := "_lc_ge_mk_stack_MK_threadStack_slot5";
    group (align=8) { reserved "rsrvd.mk_stack_MK_threadStack_slot5" (size=8); }

    group mk_stack_MK_threadStack_slot6 (contiguous, ordered, align=64)
    {
      section "mk_stack_MK_threadStack_slot6" (blocksize=8, attributes=rw)
      {
        select ".bss.mk_stack_MK_threadStack_slot6";
      }
    }
    "MK_RSA_MK_threadStack_slot6" := "_lc_gb_mk_stack_MK_threadStack_slot6";
    "MK_RLA_MK_threadStack_slot6" := "_lc_ge_mk_stack_MK_threadStack_slot6";
    group (align=8) { reserved "rsrvd.mk_stack_MK_threadStack_slot6" (size=8); }


    group mk_stack_MK_ShutdownHookStack (contiguous, ordered, align=64)
    {
      section "mk_stack_MK_ShutdownHookStack" (blocksize=8, attributes=rw)
      {
        select ".bss.mk_stack_MK_sysctrlHookStack";
      }
    }
    "MK_RSA_MK_ShutdownHookStack" := "_lc_gb_mk_stack_MK_ShutdownHookStack";
    "MK_RLA_MK_ShutdownHookStack" := "_lc_ge_mk_stack_MK_ShutdownHookStack";
    "MK_RSA_MK_StartupHookStack"  := "_lc_gb_mk_stack_MK_ShutdownHookStack";
    "MK_RLA_MK_StartupHookStack"  := "_lc_ge_mk_stack_MK_ShutdownHookStack";
    group (align=8) { reserved "rsrvd.mk_stack_MK_ShutdownHookStack" (size=8); }

  }

  // -----------------------------------------------------------
  // The first memory region MK_Ram containing MK variables
  // -----------------------------------------------------------

  group AREA_MK_Ram (contiguous, ordered, run_addr = mem:int_ram, align=64)
  {
    section "MK_Ram" (blocksize=8, attributes=rw)
    {
        group MK_Ram_data (align=4)
        {
          select ".data.Mk_*";
        }
        group MK_Ram_bss (align=4)
        {
          select ".bss.Mk_*";
        }
    }
  }

  group AREA_INIT_MK_Ram (contiguous, ordered, load_addr = mem:int_rom_1, align=8)
  {
    group initdata_MK_Ram (contiguous, ordered, align=4)
    {
      select ".data.Mk_*";
    }
  }

  group AREA_MK_OsRam (contiguous, ordered, run_addr = mem:int_ram, align=64)
  {
    section "AREA_MK_OsRam" (blocksize=8, attributes=rw)
    {
      group MK_OsRam_data (align=4)
      {
        select ".data.kern-*";
        select ".data.TRICORE-*";
        select ".data.Os_*";
      }
      group MK_OsRam_bss (align=4)
      {
        select ".bss.kern-*";
        select ".bss.TRICORE-*";
        select ".bss.Os_*";
      }
    }
  }

  group AREA_INIT_MK_OsRam (contiguous, ordered, load_addr = mem:int_rom_1, align=8)
  {
    group initdata_MK_OsRam (contiguous, ordered, align=4)
    {
      select ".data.kern-*";
      select ".data.TRICORE-*";
      select ".data.Os_*";
    }
  }

  group __AREA_initdata (contiguous, ordered, load_addr = mem:int_rom_1, align=8)
  {
    group initdata.TRICORE (contiguous, ordered, align=64)
    {
      group (align=4) {
        select ".data*";
        select ".zdata*";
      }
    }
  }

  group __AREA_databss (contiguous, ordered, run_addr = mem:int_ram)
  {


    group data.TRICORE (align=4)
    {
      group (align=4) {
        select ".data*";
        select ".zdata*";
      }
    }

    group bss.TRICORE (align=4)
    {
      select ".bss*";
      select ".zbss*";
    }

  }

  // Symbols of memory regions not bound to any object file
  "MK_RSA_MK_Rom"    := 0x80000000; // Flash
  "MK_RLA_MK_Rom"    := 0x80400000;
  "MK_RSA_MK_Io"     := 0xF0000000; // I/O
  "MK_RLA_MK_Io"     := 0xFF120000;
  "MK_RSA_MK_ReadOnlyRam" := 0xd0000000; // whole RAM
  "MK_RLA_MK_ReadOnlyRam" := 0xd0020000;
  "MK_RSA_MK_GlobalRam" := 0xd0000000;
  "MK_RLA_MK_GlobalRam" := "MK_RSA_MK_Csa";
  "MK_RSA_MK_OsIo"   := 0xF0000000; // OS I/O (STM only!!!)
  "MK_RLA_MK_OsIo"   := 0xF0000300;

  "MK_RSA_MK_Ram"    := "_lc_gb_AREA_MK_Ram";
  "MK_RLA_MK_Ram"    := "_lc_ge_AREA_MK_Ram";
  "MK_RDA_MK_Ram"    := "_lc_gb_AREA_INIT_MK_Ram";
  "MK_BSA_MK_Ram"    := "_lc_gb_MK_Ram_bss";

  "MK_RSA_MK_OsRam"  := "_lc_gb_AREA_MK_OsRam";
  "MK_RLA_MK_OsRam"  := "_lc_ge_AREA_MK_OsRam";
  "MK_RDA_MK_OsRam"  := "_lc_gb_AREA_INIT_MK_OsRam";
  "MK_BSA_MK_OsRam"  := "_lc_gb_MK_OsRam_bss";

  // Symbols for the global initialisation.
  "MK_ANON_IDAT"     := "_lc_gb_initdata.TRICORE";
  "MK_ANON_DATA"     := "_lc_gb_data.TRICORE";
  "MK_ANON_DATA_END" := "_lc_ge_data.TRICORE";
  "MK_ANON_BSS"      := "_lc_gb_bss.TRICORE";
  "MK_ANON_BSS_END"  := "_lc_ge_bss.TRICORE";

  // Symbols for the initialisation of private data areas.
  "MK_INITIAL_A0"       := 0;
  "MK_INITIAL_A1"       := 0;
  "MK_INITIAL_A8"       := 0; // reserved for OS use


  // Symbols for the initialisation of private data areas.
  // Empty private Data of task Init_Task
  "MK_RDA_Init_Task" := 0;
  "MK_RSA_Init_Task" := 100;
  "MK_BSA_Init_Task" := 100;
  "MK_RLA_Init_Task" := 100;

  // Empty private Data of task SchMBswTask
  "MK_RDA_SchMBswTask" := 0;
  "MK_RSA_SchMBswTask" := 100;
  "MK_BSA_SchMBswTask" := 100;
  "MK_RLA_SchMBswTask" := 100;

  // Empty private Data of task Appl_Task_1ms
  "MK_RDA_Appl_Task_1ms" := 0;
  "MK_RSA_Appl_Task_1ms" := 100;
  "MK_BSA_Appl_Task_1ms" := 100;
  "MK_RLA_Appl_Task_1ms" := 100;

  // Empty private Data of task Appl_Task_5ms
  "MK_RDA_Appl_Task_5ms" := 0;
  "MK_RSA_Appl_Task_5ms" := 100;
  "MK_BSA_Appl_Task_5ms" := 100;
  "MK_RLA_Appl_Task_5ms" := 100;

  // Empty private Data of task SchMComTask
  "MK_RDA_SchMComTask" := 0;
  "MK_RSA_SchMComTask" := 100;
  "MK_BSA_SchMComTask" := 100;
  "MK_RLA_SchMComTask" := 100;

  // Empty private Data of task Appl_Task_5ms_Entry
  "MK_RDA_Appl_Task_5ms_Entry" := 0;
  "MK_RSA_Appl_Task_5ms_Entry" := 100;
  "MK_BSA_Appl_Task_5ms_Entry" := 100;
  "MK_RLA_Appl_Task_5ms_Entry" := 100;

}
